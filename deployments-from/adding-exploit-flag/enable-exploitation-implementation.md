# Implementation: --enable-exploitation Parameter

## Overview
Adding `--enable-exploitation` flag to shannon.mjs to give you explicit control over whether the exploitation phase runs.

## Files to Modify

### 1. shannon.mjs (CLI Definition)

**Location**: Line ~60 (in the `generate` command options)

**Add this option**:
```javascript
.option('--enable-exploitation', 'Enable active exploitation phase (requires nuclei, sqlmap, etc.)')
```

**Full context** (around line 50-75):
```javascript
// GENERATE COMMAND (Local Source Generator)
program
  .command('generate')
  .description('Generate synthetic local source from black-box reconnaissance')
  .argument('<target>', 'Target URL')
  .option('-o, --output <dir>', 'Output directory', './shannon-results')
  .option('--skip-nmap', 'Skip nmap port scan')
  .option('--skip-crawl', 'Skip active crawling')
  .option('--timeout <ms>', 'Global timeout for tools in ms', parseInt)
  .option('--no-ai', 'Skip AI-powered code synthesis (recon only)')
  .option('--framework <n>', 'Target framework for synthesis (express, fastapi)', 'express')
  .option('--no-msf', 'Disable Metasploit integration')
  .option('--msf-host <host>', 'Metasploit RPC host')
  .option('--msf-port <port>', 'Metasploit RPC port', parseInt)
  .option('--msf-user <user>', 'Metasploit RPC user')
  .option('--msf-pass <pass>', 'Metasploit RPC password')
  .option('-p, --parallel <number>', 'Max parallel agents', '4')
  .option('-v, --verbose', 'Verbose output')
  .option('--debug-tools', 'Log external tool commands and outputs to workspace')
  .option('--agents <list>', 'Comma-separated agent names to run (include only these)')
  .option('--exclude-agents <list>', 'Comma-separated agent names to skip')
  .option('--no-resume', 'Do not skip previously completed agents even if a workspace exists')
  .option('--top-ports <n>', 'For NetReconAgent: use nmap --top-ports N', parseInt)
  .option('--ports <spec>', 'For NetReconAgent: port list/range (e.g., 80,443,1-1024)')
  .option('--enable-exploitation', 'Enable active exploitation phase (requires nuclei, sqlmap, etc.)')  // ← ADD THIS
  .action(async (target, options) => {
```

**Then pass it through** (around line 95):
```javascript
const result = await generateLocalSource(target, options.output, {
  skipNmap: options.skipNmap,
  skipCrawl: options.skipCrawl,
  timeout: options.timeout,
  enableAI: options.ai !== false,
  framework: options.framework,
  noMsf: !options.msf,
  msfHost: options.msfHost,
  msfPort: options.msfPort,
  msfUser: options.msfUser,
  msfPass: options.msfPass,
  parallel: parseInt(options.parallel),
  verbose: options.verbose,
  debugTools: !!options.debugTools,
  includeAgents,
  excludeAgents,
  resume: options.resume === false || options.noResume ? false : true,
  enableExploitation: options.enableExploitation || false  // ← ADD THIS
});
```

### 2. local-source-generator.mjs (Pipeline Orchestration)

**Location**: Around line 75-130 (where excludeAgents is built)

**Modify the exclude logic**:

```javascript
// Compute final exclude list based on include/exclude agent filters
let finalExclude = Array.isArray(options.excludeAgents) ? [...options.excludeAgents] : [];

// Add exploitation agents to exclude list if not explicitly enabled
if (!options.enableExploitation) {
    const exploitationAgents = [
        'NucleiScanAgent',
        'SQLmapAgent',
        'XSSValidatorAgent',
        'CommandInjectionAgent',
        'MetasploitExploit'
    ];
    
    // Only exclude if not explicitly included via --agents
    const includeSet = Array.isArray(options.includeAgents) 
        ? new Set(options.includeAgents) 
        : null;
    
    for (const agent of exploitationAgents) {
        // Don't exclude if explicitly included
        if (!includeSet || !includeSet.has(agent)) {
            if (!finalExclude.includes(agent)) {
                finalExclude.push(agent);
            }
        }
    }
    
    if (!options.quiet) {
        console.log(chalk.yellow('⚠️  Exploitation phase disabled (use --enable-exploitation to enable)'));
    }
}

// Existing logic for includeAgents
if (Array.isArray(options.includeAgents) && options.includeAgents.length > 0) {
    const includeSet = new Set(options.includeAgents);
    const allAgents = orchestrator.registry.list();
    for (const name of allAgents) {
        if (!includeSet.has(name) && !finalExclude.includes(name)) {
            finalExclude.push(name);
        }
    }
}
```

**Full context** (around line 75-130 in local-source-generator.mjs):
```javascript
const result = await orchestrator.runFullPipeline(webUrl, sourceDir, {
    framework: options.framework || 'express',
    msfrpcConfig, // Pass to all agents in inputs
    excludeAgents: [
        ...(options.noMsf ? ['MetasploitRecon', 'MetasploitExploit'] : []),
        ...finalExclude  // ← This now includes exploitation agents if disabled
    ],
    topPorts: options.topPorts,
    ports: options.ports,
    resume: options.resume !== undefined ? options.resume : true
});
```

### 3. README.md (Documentation)

**Add to the CLI examples section**:

```markdown
### Exploitation Control

By default, the exploitation phase is **disabled** to avoid accidentally running active attacks. Enable it explicitly:

```bash
# Enable exploitation (requires tools: nuclei, sqlmap, xsstrike, commix)
./shannon.mjs generate https://target.com --enable-exploitation

# Exploitation with Metasploit
./shannon.mjs generate https://target.com \
  --enable-exploitation \
  --msf-host 127.0.0.1 \
  --msf-port 55553 \
  --msf-user msf \
  --msf-pass msf
```

**Note**: Exploitation requires these tools to be installed:
- `nuclei` - CVE scanner
- `sqlmap` - SQL injection tester
- `xsstrike` - XSS validator
- `commix` - Command injection tester
- `msfrpcd` - Metasploit RPC (if using Metasploit)
```

## Complete Code Changes

### File 1: shannon.mjs

**Find** (around line 60):
```javascript
  .option('--ports <spec>', 'For NetReconAgent: port list/range (e.g., 80,443,1-1024)')
  .action(async (target, options) => {
```

**Replace with**:
```javascript
  .option('--ports <spec>', 'For NetReconAgent: port list/range (e.g., 80,443,1-1024)')
  .option('--enable-exploitation', 'Enable active exploitation phase (requires nuclei, sqlmap, etc.)')
  .action(async (target, options) => {
```

**Find** (around line 85):
```javascript
      const result = await generateLocalSource(target, options.output, {
        skipNmap: options.skipNmap,
        skipCrawl: options.skipCrawl,
        timeout: options.timeout,
        enableAI: options.ai !== false,
        framework: options.framework,
        noMsf: !options.msf,
        msfHost: options.msfHost,
        msfPort: options.msfPort,
        msfUser: options.msfUser,
        msfPass: options.msfPass,
        parallel: parseInt(options.parallel),
        verbose: options.verbose,
        debugTools: !!options.debugTools,
        includeAgents,
        excludeAgents,
        resume: options.resume === false || options.noResume ? false : true
      });
```

**Replace with**:
```javascript
      const result = await generateLocalSource(target, options.output, {
        skipNmap: options.skipNmap,
        skipCrawl: options.skipCrawl,
        timeout: options.timeout,
        enableAI: options.ai !== false,
        framework: options.framework,
        noMsf: !options.msf,
        msfHost: options.msfHost,
        msfPort: options.msfPort,
        msfUser: options.msfUser,
        msfPass: options.msfPass,
        parallel: parseInt(options.parallel),
        verbose: options.verbose,
        debugTools: !!options.debugTools,
        includeAgents,
        excludeAgents,
        resume: options.resume === false || options.noResume ? false : true,
        enableExploitation: options.enableExploitation || false
      });
```

### File 2: local-source-generator.mjs

**Find** (around line 75-100, the section with "Compute final exclude list"):
```javascript
        // Compute final exclude list based on include/exclude agent filters
        let finalExclude = Array.isArray(options.excludeAgents) ? [...options.excludeAgents] : [];
        if (Array.isArray(options.includeAgents) && options.includeAgents.length > 0) {
            const includeSet = new Set(options.includeAgents);
            const allAgents = orchestrator.registry.list();
            for (const name of allAgents) {
                if (!includeSet.has(name) && !finalExclude.includes(name)) {
                    finalExclude.push(name);
                }
            }
        }
```

**Replace with**:
```javascript
        // Compute final exclude list based on include/exclude agent filters
        let finalExclude = Array.isArray(options.excludeAgents) ? [...options.excludeAgents] : [];
        
        // Add exploitation agents to exclude list if not explicitly enabled
        if (!options.enableExploitation) {
            const exploitationAgents = [
                'NucleiScanAgent',
                'SQLmapAgent',
                'XSSValidatorAgent',
                'CommandInjectionAgent',
                'MetasploitExploit'
            ];
            
            // Only exclude if not explicitly included via --agents
            const includeSet = Array.isArray(options.includeAgents) 
                ? new Set(options.includeAgents) 
                : null;
            
            for (const agent of exploitationAgents) {
                // Don't exclude if explicitly included
                if (!includeSet || !includeSet.has(agent)) {
                    if (!finalExclude.includes(agent)) {
                        finalExclude.push(agent);
                    }
                }
            }
            
            if (!options.quiet) {
                console.log(chalk.yellow('⚠️  Exploitation phase disabled (use --enable-exploitation to enable)'));
            }
        }
        
        // Handle includeAgents filter
        if (Array.isArray(options.includeAgents) && options.includeAgents.length > 0) {
            const includeSet = new Set(options.includeAgents);
            const allAgents = orchestrator.registry.list();
            for (const name of allAgents) {
                if (!includeSet.has(name) && !finalExclude.includes(name)) {
                    finalExclude.push(name);
                }
            }
        }
```

## Usage Examples

### Default (Exploitation Disabled)
```bash
# Safe reconnaissance and analysis only
./shannon.mjs generate http://192.168.1.130:3000 \
  -o ./safe-scan-$(date +%s) \
  -v
```

Output will show:
```
⚠️  Exploitation phase disabled (use --enable-exploitation to enable)
```

### Enable Exploitation
```bash
# Full attack chain including exploitation
./shannon.mjs generate http://192.168.1.130:3000 \
  -o ./full-scan-$(date +%s) \
  --enable-exploitation \
  -v
```

### Exploitation with Metasploit
```bash
# Exploitation + Metasploit
./shannon.mjs generate http://192.168.1.130:3000 \
  -o ./msf-scan-$(date +%s) \
  --enable-exploitation \
  --msf-host 127.0.0.1 \
  --msf-port 55553 \
  --msf-user msf \
  --msf-pass msf \
  -v
```

### Selective Exploitation
```bash
# Only run specific exploitation agents
./shannon.mjs generate http://192.168.1.130:3000 \
  -o ./selective-$(date +%s) \
  --enable-exploitation \
  --agents NetReconAgent,CrawlerAgent,NucleiScanAgent,SQLmapAgent \
  -v
```

## Benefits of This Approach

1. **Safe by Default**: Exploitation is opt-in, preventing accidental active attacks
2. **Clear Intent**: The flag name makes it obvious what you're enabling
3. **Backwards Compatible**: Existing commands work the same (exploitation disabled)
4. **Override Mechanism**: `--agents` can still explicitly include exploitation agents
5. **User Feedback**: Clear warning message when exploitation is disabled
6. **Tool Independence**: Works regardless of whether tools are installed

## Testing the Implementation

### Test 1: Default Behavior (Exploitation Off)
```bash
./shannon.mjs generate https://example.com -o ./test1 -v
# Should show: "⚠️  Exploitation phase disabled"
# Should NOT run: NucleiScanAgent, SQLmapAgent, etc.
```

### Test 2: Enable Exploitation
```bash
./shannon.mjs generate https://example.com -o ./test2 --enable-exploitation -v
# Should NOT show warning
# Should run: NucleiScanAgent, SQLmapAgent, XSSValidatorAgent, etc.
```

### Test 3: Explicit Agent Selection Overrides
```bash
./shannon.mjs generate https://example.com -o ./test3 \
  --agents NucleiScanAgent -v
# Should run ONLY NucleiScanAgent (ignores --enable-exploitation)
```

### Test 4: Help Text
```bash
./shannon.mjs generate --help
# Should show: "--enable-exploitation  Enable active exploitation phase"
```

## Migration Guide

If you have existing scripts or commands:

**Old way** (exploitation ran if tools were available):
```bash
./shannon.mjs generate http://target.com
```

**New way** (explicitly enable when needed):
```bash
./shannon.mjs generate http://target.com --enable-exploitation
```

To update your scripts, just add `--enable-exploitation` where you want active testing.

## Summary

This implementation gives you explicit control over the exploitation phase through a single, clear flag. It's:
- ✅ Safe by default
- ✅ Easy to understand
- ✅ Works with existing filters
- ✅ Backwards compatible
- ✅ Provides clear feedback

The exploitation phase will only run when you explicitly add `--enable-exploitation` to your command.
