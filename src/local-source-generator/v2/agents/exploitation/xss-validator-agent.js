/**
 * XSSValidatorAgent - XSS vulnerability validation
 * 
 * Validates XSS hypotheses using xsstrike or manual payloads
 * to confirm reflected/stored/DOM XSS vulnerabilities.
 */

import { BaseAgent } from '../base-agent.js';
import { runTool, isToolAvailable } from '../../tools/runners/tool-runner.js';

export class XSSValidatorAgent extends BaseAgent {
    constructor(options = {}) {
        super('XSSValidatorAgent', options);

        this.inputs_schema = {
            type: 'object',
            required: ['target'],
            properties: {
                target: { type: 'string', description: 'Target URL with parameter' },
                parameter: { type: 'string', description: 'Parameter name to test' },
                method: {
                    type: 'string',
                    enum: ['GET', 'POST'],
                    default: 'GET'
                },
                data: { type: 'string', description: 'POST data for POST requests' },
                crawl: {
                    type: 'boolean',
                    default: true,
                    description: 'Enable crawling for additional injection points'
                }
            }
        };

        this.outputs_schema = {
            type: 'object',
            properties: {
                vulnerable: { type: 'boolean' },
                vulnerabilities: { type: 'array' },
                summary: { type: 'object' }
            }
        };

        this.requires = {
            evidence_kinds: ['parameter_found', 'xss_hypothesis'],
            model_nodes: ['parameters', 'endpoints']
        };

        this.emits = {
            evidence_events: ['xss_confirmed', 'xss_tested'],
            model_updates: ['vulnerability_confirmed'],
            claims: ['xss_vulnerability', 'reflected_xss', 'stored_xss', 'dom_xss'],
            artifacts: ['xss_validation_results.json']
        };

        this.default_budget = {
            max_time_ms: 180000,
            max_network_requests: 100,
            max_tokens: 0,
            max_tool_invocations: 1
        };

        // XSS payloads for manual testing
        this.payloads = [
            '<script>alert(1)</script>',
            '"><script>alert(1)</script>',
            "'-alert(1)-'",
            '<img src=x onerror=alert(1)>',
            '<svg onload=alert(1)>',
            '{{constructor.constructor("alert(1)")()}}',
            '${alert(1)}',
            'javascript:alert(1)',
            '<body onload=alert(1)>',
            '<marquee onstart=alert(1)>',
        ];

        // Response patterns indicating successful injection
        this.successPatterns = [
            /<script>alert\(1\)<\/script>/i,
            /onerror\s*=\s*alert/i,
            /onload\s*=\s*alert/i,
            /javascript:alert/i,
            /<svg[^>]*onload/i,
            /<img[^>]*onerror/i,
        ];
    }

    /**
     * Run xsstrike if available
     */
    async runXsstrike(target, options = {}) {
        const { crawl = true, data, method = 'GET' } = options;

        let cmd = `xsstrike -u "${target}"`;

        if (method === 'POST' && data) {
            cmd += ` --data "${data}"`;
        }

        if (crawl) {
            cmd += ' --crawl';
        }

        cmd += ' --skip-dom';  // Speed up scan

        const result = await runTool(cmd, { timeout: 180000 });
        return this.parseXsstrikeOutput(result.stdout || '');
    }

    /**
     * Parse xsstrike output
     */
    parseXsstrikeOutput(stdout) {
        const vulnerabilities = [];
        const lines = stdout.split('\n');

        let currentVuln = null;

        for (const line of lines) {
            // Detect vulnerability marker
            if (line.includes('Vulnerable') || line.includes('[+]')) {
                if (currentVuln) {
                    vulnerabilities.push(currentVuln);
                }
                currentVuln = {
                    type: 'xss',
                    confirmed: true,
                    source: 'xsstrike'
                };
            }

            // Extract parameter
            if (line.includes('Parameter:') && currentVuln) {
                const match = line.match(/Parameter:\s*(\S+)/);
                if (match) {
                    currentVuln.parameter = match[1];
                }
            }

            // Extract payload
            if (line.includes('Payload:') && currentVuln) {
                const match = line.match(/Payload:\s*(.+)/);
                if (match) {
                    currentVuln.payload = match[1].trim();
                }
            }

            // Classify type
            if (line.toLowerCase().includes('reflected') && currentVuln) {
                currentVuln.xssType = 'reflected';
            } else if (line.toLowerCase().includes('stored') && currentVuln) {
                currentVuln.xssType = 'stored';
            } else if (line.toLowerCase().includes('dom') && currentVuln) {
                currentVuln.xssType = 'dom';
            }
        }

        if (currentVuln) {
            vulnerabilities.push(currentVuln);
        }

        return vulnerabilities;
    }

    /**
     * Manual payload testing fallback
     */
    async manualTest(target, parameter) {
        const vulnerabilities = [];

        for (const payload of this.payloads) {
            try {
                const url = new URL(target);
                url.searchParams.set(parameter, payload);

                const response = await fetch(url.toString(), {
                    redirect: 'follow',
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (XSS-Validator)'
                    }
                });

                const body = await response.text();

                // Check if payload reflected in response
                for (const pattern of this.successPatterns) {
                    if (pattern.test(body)) {
                        vulnerabilities.push({
                            type: 'xss',
                            xssType: 'reflected',
                            confirmed: true,
                            parameter,
                            payload,
                            url: url.toString(),
                            source: 'manual_test'
                        });
                        break;
                    }
                }
            } catch (error) {
                // Request failed, continue
            }
        }

        return vulnerabilities;
    }

    /**
     * Main execution
     */
    async run(ctx, inputs) {
        const { target, parameter, method = 'GET', data, crawl = true } = inputs;

        let vulnerabilities = [];
        let tool = 'manual';

        // Try xsstrike first
        if (await isToolAvailable('xsstrike')) {
            ctx.recordToolInvocation();
            vulnerabilities = await this.runXsstrike(target, { crawl, data, method });
            tool = 'xsstrike';
        } else if (parameter) {
            // Manual testing fallback
            ctx.recordToolInvocation();
            vulnerabilities = await this.manualTest(target, parameter);
            tool = 'manual';
        }

        // Emit evidence for test
        ctx.emitEvidence({
            type: 'xss_tested',
            source: this.name,
            data: { target, parameter, tool, vulnCount: vulnerabilities.length }
        });

        // Process vulnerabilities
        const summary = {
            total: vulnerabilities.length,
            byType: { reflected: 0, stored: 0, dom: 0, unknown: 0 }
        };

        for (const vuln of vulnerabilities) {
            ctx.recordNetworkRequest();

            const xssType = vuln.xssType || 'unknown';
            summary.byType[xssType] = (summary.byType[xssType] || 0) + 1;

            // Emit evidence
            const evidenceId = ctx.emitEvidence({
                type: 'xss_confirmed',
                source: this.name,
                data: vuln
            });

            // Emit claim
            const claimType = xssType === 'reflected' ? 'reflected_xss' :
                xssType === 'stored' ? 'stored_xss' :
                    xssType === 'dom' ? 'dom_xss' :
                        'xss_vulnerability';

            ctx.emitClaim({
                claim_type: claimType,
                subject: vuln.url || target,
                predicate: {
                    parameter: vuln.parameter,
                    payload: vuln.payload,
                    type: xssType
                },
                base_rate: 0.05
            });

            // Add EBSL evidence
            ctx.ledger.addEvidence(
                ctx.ledger.generateClaimId(claimType, vuln.url || target),
                'active_probe_success',
                1.0,
                this.name,
                evidenceId
            );
        }

        return {
            vulnerable: vulnerabilities.length > 0,
            vulnerabilities,
            tool,
            summary
        };
    }
}

export default XSSValidatorAgent;
