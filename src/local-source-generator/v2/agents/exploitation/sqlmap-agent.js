/**
 * SQLmapAgent - Automated SQL Injection detection and exploitation
 * 
 * Validates SQL injection hypotheses using sqlmap with proper
 * EBSL evidence emission for confirmed vulnerabilities.
 */

import { BaseAgent } from '../base-agent.js';
import { runTool } from '../../tools/runners/tool-runner.js';
import { CLAIM_TYPES } from '../../epistemics/ledger.js';

export class SQLmapAgent extends BaseAgent {
    constructor(options = {}) {
        super('SQLmapAgent', options);

        this.inputs_schema = {
            type: 'object',
            required: ['target'],
            properties: {
                target: {
                    type: 'string',
                    description: 'Target URL with injection point (use * for injection marker)'
                },
                method: {
                    type: 'string',
                    enum: ['GET', 'POST'],
                    default: 'GET'
                },
                data: {
                    type: 'string',
                    description: 'POST data (for POST requests)'
                },
                cookie: {
                    type: 'string',
                    description: 'Cookie header value'
                },
                level: {
                    type: 'number',
                    minimum: 1,
                    maximum: 5,
                    default: 2,
                    description: 'Level of tests (1-5, higher = more tests)'
                },
                risk: {
                    type: 'number',
                    minimum: 1,
                    maximum: 3,
                    default: 1,
                    description: 'Risk level (1-3, higher = more risky tests)'
                },
                forms: {
                    type: 'boolean',
                    default: true,
                    description: 'Automatically test forms'
                },
                crawlDepth: {
                    type: 'number',
                    default: 1,
                    description: 'Crawl depth for form discovery'
                }
            }
        };

        this.outputs_schema = {
            type: 'object',
            properties: {
                vulnerable: { type: 'boolean' },
                injections: { type: 'array' },
                databases: { type: 'array' },
                summary: { type: 'object' }
            }
        };

        this.requires = {
            evidence_kinds: ['parameter_found', 'injection_hypothesis'],
            model_nodes: ['parameters', 'forms']
        };

        this.emits = {
            evidence_events: ['sqli_confirmed', 'sqli_tested', 'database_enumerated'],
            model_updates: ['injection_confirmed'],
            claims: ['sqli_vulnerability', 'database_exposed'],
            artifacts: ['sqlmap_results.json']
        };

        this.default_budget = {
            max_time_ms: 300000,        // 5 minutes
            max_network_requests: 200,
            max_tokens: 0,
            max_tool_invocations: 1
        };
    }

    /**
     * Build sqlmap command with options
     */
    buildCommand(inputs) {
        const {
            target,
            method = 'GET',
            data,
            cookie,
            level = 2,
            risk = 1,
            forms = true,
            crawlDepth = 1
        } = inputs;

        let cmd = `sqlmap -u "${target}" --batch --output-dir=/tmp/sqlmap_output`;

        // Method
        if (method === 'POST' && data) {
            cmd += ` --data="${data}"`;
        }

        // Authentication
        if (cookie) {
            cmd += ` --cookie="${cookie}"`;
        }

        // Test configuration
        cmd += ` --level=${level} --risk=${risk}`;

        // Form handling
        if (forms) {
            cmd += ' --forms';
            cmd += ` --crawl=${crawlDepth}`;
        }

        // Output format
        cmd += ' --answers="crack=N,dict=N,continue=Y,quit=N"';

        // Text markers for parsing
        cmd += ' --text-only';

        return cmd;
    }

    /**
     * Parse sqlmap output for vulnerabilities
     */
    parseOutput(stdout) {
        const result = {
            vulnerable: false,
            injections: [],
            databases: [],
            parameters: []
        };

        const lines = stdout.split('\n');

        let currentParam = null;
        let inInjectionBlock = false;

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];

            // Detect vulnerability confirmation
            if (line.includes('is vulnerable') || line.includes('parameter is vulnerable')) {
                result.vulnerable = true;
            }

            // Detect injection type
            if (line.includes('Type:')) {
                const typeMatch = line.match(/Type:\s*(.+)/);
                if (typeMatch && currentParam) {
                    result.injections.push({
                        parameter: currentParam,
                        type: typeMatch[1].trim(),
                        line: line.trim()
                    });
                }
            }

            // Detect parameter being tested
            if (line.includes('testing for SQL injection on')) {
                const paramMatch = line.match(/parameter '([^']+)'/);
                if (paramMatch) {
                    currentParam = paramMatch[1];
                    result.parameters.push(currentParam);
                }
            }

            // Detect databases
            if (line.includes('available databases')) {
                // Look for database names in following lines
                for (let j = i + 1; j < lines.length && j < i + 20; j++) {
                    const dbMatch = lines[j].match(/\[\*\]\s*(\w+)/);
                    if (dbMatch) {
                        result.databases.push(dbMatch[1]);
                    }
                    if (lines[j].trim() === '' || lines[j].includes('[')) {
                        break;
                    }
                }
            }

            // Detect backend DBMS
            if (line.includes('back-end DBMS:')) {
                const dbmsMatch = line.match(/back-end DBMS:\s*(.+)/);
                if (dbmsMatch) {
                    result.dbms = dbmsMatch[1].trim();
                }
            }

            // Detect OS (from banner)
            if (line.includes('operating system:')) {
                const osMatch = line.match(/operating system:\s*(.+)/);
                if (osMatch) {
                    result.os = osMatch[1].trim();
                }
            }
        }

        // Deduplicate
        result.parameters = [...new Set(result.parameters)];
        result.databases = [...new Set(result.databases)];

        return result;
    }

    /**
     * Determine severity based on injection type
     */
    getSeverity(injectionType) {
        const type = injectionType?.toLowerCase() || '';

        if (type.includes('stacked') || type.includes('out-of-band')) {
            return 'critical';
        }
        if (type.includes('union') || type.includes('error-based')) {
            return 'high';
        }
        if (type.includes('boolean-based') || type.includes('time-based')) {
            return 'high';
        }
        return 'medium';
    }

    /**
     * Main execution
     */
    async run(ctx, inputs) {
        const {
            target,
            method = 'GET',
            data,
            cookie,
            level = 2,
            risk = 1,
            forms = true,
            crawlDepth = 1
        } = inputs;

        const startTime = Date.now();

        // Ensure tool is available; otherwise skip gracefully
        const { isToolAvailable } = await import('../../tools/runners/tool-runner.js');
        const available = await isToolAvailable('sqlmap');
        if (!available) {
            return {
                vulnerable: false,
                injections: [],
                databases: [],
                parameters: [],
                summary: {
                    target,
                    vulnerable: false,
                    injectionCount: 0,
                    databaseCount: 0,
                    scanDuration: 0,
                    skipped: 'sqlmap not available'
                }
            };
        }

        // Build and run sqlmap
        const command = this.buildCommand({
            target, method, data, cookie, level, risk, forms, crawlDepth
        });

        ctx.recordToolInvocation();
        const toolResult = await runTool(command, {
            timeout: 300000, // 5 minute timeout
            context: ctx,
        });

        // Parse results
        const result = this.parseOutput(toolResult.stdout || '');
        result.scanDuration = Date.now() - startTime;
        result.target = target;

        // Emit evidence for test
        const testEvidenceId = ctx.emitEvidence({
            type: 'sqli_tested',
            source: this.name,
            data: {
                target,
                vulnerable: result.vulnerable,
                parametersTest: result.parameters.length,
                dbms: result.dbms
            }
        });

        if (result.vulnerable) {
            // Emit evidence for confirmed vulnerability
            const vulnEvidenceId = ctx.emitEvidence({
                type: 'sqli_confirmed',
                source: this.name,
                data: {
                    target,
                    injections: result.injections,
                    dbms: result.dbms,
                    databases: result.databases
                }
            });

            // Emit claims for each injection point
            for (const injection of result.injections) {
                const severity = this.getSeverity(injection.type);

                ctx.emitClaim({
                    claim_type: 'sqli_vulnerability',
                    subject: target,
                    predicate: {
                        parameter: injection.parameter,
                        type: injection.type,
                        severity,
                        dbms: result.dbms
                    },
                    base_rate: 0.05 // SQL injection is rare but critical
                });

                // Add EBSL evidence with high confidence
                const claimId = ctx.ledger.generateClaimId('sqli_vulnerability', target);

                ctx.ledger.addEvidence(
                    claimId,
                    'active_probe_success',
                    1.0,  // Confirmed by sqlmap
                    this.name,
                    vulnEvidenceId
                );

                ctx.ledger.addEvidence(
                    claimId,
                    'tool_confirmation',
                    1.0,
                    this.name,
                    vulnEvidenceId
                );
            }

            // If databases were enumerated, emit additional claim
            if (result.databases.length > 0) {
                ctx.emitClaim({
                    claim_type: 'database_exposed',
                    subject: target,
                    predicate: {
                        databases: result.databases,
                        dbms: result.dbms
                    },
                    base_rate: 0.01
                });
            }
        } else {
            // Add negative evidence if not vulnerable
            const claimId = ctx.ledger.generateClaimId('sqli_vulnerability', target);
            ctx.ledger.addEvidence(
                claimId,
                'active_probe_fail',
                1.0,
                this.name,
                testEvidenceId
            );
        }

        ctx.recordNetworkRequest();

        return {
            vulnerable: result.vulnerable,
            injections: result.injections,
            databases: result.databases,
            dbms: result.dbms,
            parameters: result.parameters,
            summary: {
                target,
                vulnerable: result.vulnerable,
                injectionCount: result.injections.length,
                databaseCount: result.databases.length,
                scanDuration: result.scanDuration
            }
        };
    }
}

export default SQLmapAgent;
