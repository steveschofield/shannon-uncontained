/**
 * CommandInjectionAgent - OS Command Injection validation
 * 
 * Validates command injection hypotheses using commix or
 * manual payloads to confirm OS command execution.
 */

import { BaseAgent } from '../base-agent.js';
import { runTool, isToolAvailable } from '../../tools/runners/tool-runner.js';

export class CommandInjectionAgent extends BaseAgent {
    constructor(options = {}) {
        super('CommandInjectionAgent', options);

        this.inputs_schema = {
            type: 'object',
            required: ['target'],
            properties: {
                target: { type: 'string', description: 'Target URL with parameter' },
                parameter: { type: 'string', description: 'Parameter name to test' },
                method: {
                    type: 'string',
                    enum: ['GET', 'POST'],
                    default: 'GET'
                },
                data: { type: 'string', description: 'POST data' },
                level: {
                    type: 'number',
                    minimum: 1,
                    maximum: 3,
                    default: 1,
                    description: 'Test level (1-3)'
                }
            }
        };

        this.outputs_schema = {
            type: 'object',
            properties: {
                vulnerable: { type: 'boolean' },
                vulnerabilities: { type: 'array' },
                summary: { type: 'object' }
            }
        };

        this.requires = {
            evidence_kinds: ['parameter_found', 'injection_hypothesis'],
            model_nodes: ['parameters', 'endpoints']
        };

        this.emits = {
            evidence_events: ['cmdi_confirmed', 'cmdi_tested'],
            model_updates: ['vulnerability_confirmed'],
            claims: ['command_injection', 'rce_confirmed'],
            artifacts: ['cmdi_validation_results.json']
        };

        this.default_budget = {
            max_time_ms: 180000,
            max_network_requests: 50,
            max_tokens: 0,
            max_tool_invocations: 1
        };

        // Command injection payloads
        this.payloads = [
            // Time-based detection
            { payload: '; sleep 5', type: 'time-based' },
            { payload: '| sleep 5', type: 'time-based' },
            { payload: '`sleep 5`', type: 'time-based' },
            { payload: '$(sleep 5)', type: 'time-based' },
            { payload: "'; sleep 5; echo '", type: 'time-based' },
            { payload: '& ping -c 5 127.0.0.1 &', type: 'time-based' },

            // Output-based detection  
            { payload: '; id', type: 'output', marker: /uid=\d+/ },
            { payload: '| id', type: 'output', marker: /uid=\d+/ },
            { payload: '`id`', type: 'output', marker: /uid=\d+/ },
            { payload: '$(id)', type: 'output', marker: /uid=\d+/ },
            { payload: '; whoami', type: 'output', marker: /root|www-data|apache|nginx/ },
            { payload: '| cat /etc/passwd', type: 'output', marker: /root:.*:0:0/ },

            // Windows payloads
            { payload: '& ping -n 5 127.0.0.1 &', type: 'time-based' },
            { payload: '| whoami', type: 'output', marker: /\\/ },
        ];
    }

    /**
     * Run commix if available
     */
    async runCommix(target, options = {}) {
        const { parameter, method = 'GET', data, level = 1 } = options;

        let cmd = `commix -u "${target}"`;

        if (parameter) {
            cmd += ` -p "${parameter}"`;
        }

        if (method === 'POST' && data) {
            cmd += ` --data="${data}"`;
        }

        cmd += ` --level=${level}`;
        cmd += ' --batch';
        cmd += ' --output-dir=/tmp/commix_output';

        const result = await runTool(cmd, { timeout: 180000 });
        return this.parseCommixOutput(result.stdout || '');
    }

    /**
     * Parse commix output
     */
    parseCommixOutput(stdout) {
        const vulnerabilities = [];
        const lines = stdout.split('\n');

        for (const line of lines) {
            // Detect vulnerability confirmation
            if (line.includes('is vulnerable') || line.includes('[+]') && line.includes('vulnerable')) {
                const paramMatch = line.match(/parameter '([^']+)'/);
                const techniqueMatch = line.match(/technique:\s*(\S+)/i);

                vulnerabilities.push({
                    type: 'command_injection',
                    confirmed: true,
                    parameter: paramMatch ? paramMatch[1] : 'unknown',
                    technique: techniqueMatch ? techniqueMatch[1] : 'unknown',
                    source: 'commix'
                });
            }

            // Extract payload used
            if (line.includes('Payload:')) {
                const payloadMatch = line.match(/Payload:\s*(.+)/);
                if (payloadMatch && vulnerabilities.length > 0) {
                    vulnerabilities[vulnerabilities.length - 1].payload = payloadMatch[1].trim();
                }
            }
        }

        return vulnerabilities;
    }

    /**
     * Manual time-based testing
     */
    async manualTimeBased(target, parameter) {
        const vulnerabilities = [];
        const sleepTime = 5000; // 5 seconds
        const threshold = 4000; // Detection threshold

        for (const { payload, type } of this.payloads.filter(p => p.type === 'time-based')) {
            try {
                const url = new URL(target);
                url.searchParams.set(parameter, payload);

                const startTime = Date.now();
                await fetch(url.toString(), {
                    signal: AbortSignal.timeout(10000)
                });
                const elapsed = Date.now() - startTime;

                // If response took significantly longer, likely vulnerable
                if (elapsed >= threshold) {
                    vulnerabilities.push({
                        type: 'command_injection',
                        confirmed: true,
                        parameter,
                        payload,
                        technique: 'time-based',
                        delay: elapsed,
                        source: 'manual_test'
                    });
                    break; // One confirmation is enough
                }
            } catch (error) {
                // Timeout or error
            }
        }

        return vulnerabilities;
    }

    /**
     * Main execution
     */
    async run(ctx, inputs) {
        const { target, parameter, method = 'GET', data, level = 1 } = inputs;

        let vulnerabilities = [];
        let tool = 'manual';

        // Try commix first
        if (await isToolAvailable('commix')) {
            ctx.recordToolInvocation();
            vulnerabilities = await this.runCommix(target, { parameter, method, data, level });
            tool = 'commix';
        } else if (parameter) {
            // Manual testing fallback
            ctx.recordToolInvocation();
            vulnerabilities = await this.manualTimeBased(target, parameter);
            tool = 'manual';
        }

        // Emit evidence for test
        ctx.emitEvidence({
            type: 'cmdi_tested',
            source: this.name,
            data: { target, parameter, tool, vulnCount: vulnerabilities.length }
        });

        // Build summary
        const summary = {
            total: vulnerabilities.length,
            byTechnique: {}
        };

        for (const vuln of vulnerabilities) {
            ctx.recordNetworkRequest();

            const technique = vuln.technique || 'unknown';
            summary.byTechnique[technique] = (summary.byTechnique[technique] || 0) + 1;

            // Emit evidence
            const evidenceId = ctx.emitEvidence({
                type: 'cmdi_confirmed',
                source: this.name,
                data: vuln
            });

            // Emit claim - RCE is critical
            ctx.emitClaim({
                claim_type: 'command_injection',
                subject: target,
                predicate: {
                    parameter: vuln.parameter,
                    payload: vuln.payload,
                    technique: vuln.technique,
                    severity: 'critical'
                },
                base_rate: 0.02  // Very rare but critical
            });

            // Add EBSL evidence with max weight
            ctx.ledger.addEvidence(
                ctx.ledger.generateClaimId('command_injection', target),
                'active_probe_success',
                1.0,
                this.name,
                evidenceId
            );

            ctx.ledger.addEvidence(
                ctx.ledger.generateClaimId('command_injection', target),
                'tool_confirmation',
                1.0,
                this.name,
                evidenceId
            );
        }

        return {
            vulnerable: vulnerabilities.length > 0,
            vulnerabilities,
            tool,
            summary
        };
    }
}

export default CommandInjectionAgent;
