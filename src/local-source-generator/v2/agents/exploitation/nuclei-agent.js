/**
 * NucleiScanAgent - Template-based vulnerability scanning
 * 
 * Executes Nuclei templates against target to validate hypotheses
 * and discover known CVEs, exposures, and misconfigurations.
 */

import { BaseAgent } from '../base-agent.js';
import { runTool, getToolRunOptions } from '../../tools/runners/tool-runner.js';
import { CLAIM_TYPES } from '../../epistemics/ledger.js';

export class NucleiScanAgent extends BaseAgent {
    constructor(options = {}) {
        super('NucleiScanAgent', options);

        this.inputs_schema = {
            type: 'object',
            required: ['target'],
            properties: {
                target: { type: 'string', description: 'Target URL to scan' },
                templates: {
                    type: 'array',
                    items: { type: 'string' },
                    default: ['cves', 'exposures', 'vulnerabilities', 'misconfiguration'],
                    description: 'Template categories to run'
                },
                severity: {
                    type: 'array',
                    items: { type: 'string', enum: ['info', 'low', 'medium', 'high', 'critical'] },
                    default: ['medium', 'high', 'critical'],
                    description: 'Minimum severity levels to report'
                },
                rateLimit: {
                    type: 'number',
                    default: 150,
                    description: 'Requests per second rate limit'
                }
            }
        };

        this.outputs_schema = {
            type: 'object',
            properties: {
                findings: { type: 'array' },
                summary: { type: 'object' },
                scanDuration: { type: 'number' }
            }
        };

        this.requires = {
            evidence_kinds: ['endpoint_discovered', 'tech_fingerprint'],
            model_nodes: ['endpoints', 'technologies']
        };

        this.emits = {
            evidence_events: ['nuclei_finding', 'cve_detected', 'exposure_detected'],
            model_updates: ['vulnerability_confirmed'],
            claims: ['vulnerability_confirmed', 'cve_present', 'misconfiguration_found'],
            artifacts: ['nuclei_scan_results.json']
        };

        this.default_budget = {
            max_time_ms: 300000,        // 5 minutes
            max_network_requests: 1000,  // Nuclei can make many requests
            max_tokens: 0,               // No LLM usage
            max_tool_invocations: 1      // Single nuclei run
        };
    }

    /**
     * Build nuclei command with options
     */
    buildCommand(inputs) {
        const { target, templates, severity, rateLimit } = inputs;

        let cmd = `nuclei -u "${target}" -jsonl -silent`;

        // Use tags to select categories (works without local template paths)
        if (templates && templates.length > 0) {
            cmd += ` -tags ${templates.join(',')}`;
        }

        // Add severity filter
        if (severity && severity.length > 0) {
            cmd += ` -severity ${severity.join(',')}`;
        }

        // Rate limiting
        cmd += ` -rate-limit ${rateLimit}`;

        // Timeout per request
        cmd += ' -timeout 10';

        return cmd;
    }

    /**
     * Parse nuclei JSON output
     */
    parseOutput(stdout) {
        const findings = [];
        const lines = stdout.split('\n').filter(l => l.trim());

        for (const line of lines) {
            try {
                const finding = JSON.parse(line);
                findings.push({
                    templateId: finding['template-id'],
                    templateName: finding.info?.name,
                    severity: finding.info?.severity,
                    type: finding.type,
                    host: finding.host,
                    matched: finding.matched || finding['matched-at'],
                    matcherName: finding['matcher-name'],
                    extractedResults: finding['extracted-results'],
                    description: finding.info?.description,
                    reference: finding.info?.reference,
                    tags: finding.info?.tags,
                    cve: this.extractCVE(finding),
                    timestamp: finding.timestamp
                });
            } catch (e) {
                // Skip non-JSON lines
            }
        }

        return findings;
    }

    /**
     * Extract CVE ID from finding
     */
    extractCVE(finding) {
        // Check tags for CVE
        const tags = finding.info?.tags || [];
        for (const tag of tags) {
            if (tag.toLowerCase().startsWith('cve-')) {
                return tag.toUpperCase();
            }
        }

        // Check template ID
        const templateId = finding['template-id'] || '';
        const cveMatch = templateId.match(/cve-\d{4}-\d+/i);
        if (cveMatch) {
            return cveMatch[0].toUpperCase();
        }

        return null;
    }

    /**
     * Map severity to EBSL weight
     */
    severityToWeight(severity) {
        const weights = {
            critical: 1.0,
            high: 0.9,
            medium: 0.7,
            low: 0.5,
            info: 0.3
        };
        return weights[severity?.toLowerCase()] || 0.5;
    }

    /**
     * Main execution
     */
    async run(ctx, inputs) {
        const {
            target,
            templates = ['cves', 'exposures', 'vulnerabilities', 'misconfiguration'],
            severity = ['medium', 'high', 'critical'],
            rateLimit = 150
        } = inputs;

        const startTime = Date.now();

        // Build and run nuclei command
        const command = this.buildCommand({ target, templates, severity, rateLimit });

        ctx.recordToolInvocation();
        const toolOptions = getToolRunOptions('nuclei', inputs.toolConfig);
        const result = await runTool(command, {
            timeout: toolOptions.timeout,
            context: ctx,
        });

        if (!result.success && !result.stdout) {
            return {
                findings: [],
                summary: { total: 0, error: result.error },
                scanDuration: Date.now() - startTime
            };
        }

        // Parse findings
        const findings = this.parseOutput(result.stdout);

        // Emit evidence and claims for each finding
        for (const finding of findings) {
            ctx.recordNetworkRequest();

            // Determine evidence type
            const eventType = finding.cve ? 'cve_detected' :
                finding.type === 'exposure' ? 'exposure_detected' :
                    'nuclei_finding';

            // Emit evidence event
            const evidenceId = ctx.emitEvidence({
                type: eventType,
                source: this.name,
                data: {
                    templateId: finding.templateId,
                    templateName: finding.templateName,
                    severity: finding.severity,
                    host: finding.host,
                    matched: finding.matched,
                    cve: finding.cve,
                    description: finding.description
                }
            });

            // Emit claim with EBSL dimensions
            const claimType = finding.cve ? 'cve_present' :
                finding.type === 'exposure' ? 'misconfiguration_found' :
                    'vulnerability_confirmed';

            ctx.emitClaim({
                claim_type: claimType,
                subject: finding.matched || finding.host,
                predicate: {
                    templateId: finding.templateId,
                    severity: finding.severity,
                    cve: finding.cve,
                    description: finding.templateName
                },
                base_rate: 0.1 // Vulnerabilities are relatively rare
            });

            // Add evidence with proper EBSL dimensions
            const weight = this.severityToWeight(finding.severity);
            ctx.ledger.addEvidence(
                ctx.ledger.generateClaimId(claimType, finding.matched || finding.host),
                'active_probe_success',
                weight,
                this.name,
                evidenceId
            );

            // Tool confirmation dimension
            ctx.ledger.addEvidence(
                ctx.ledger.generateClaimId(claimType, finding.matched || finding.host),
                'tool_confirmation',
                1.0,
                this.name,
                evidenceId
            );
        }

        // Build summary
        const summary = {
            total: findings.length,
            bySeverity: {},
            byType: {},
            cves: findings.filter(f => f.cve).map(f => f.cve)
        };

        for (const finding of findings) {
            const sev = finding.severity || 'unknown';
            summary.bySeverity[sev] = (summary.bySeverity[sev] || 0) + 1;

            const type = finding.type || 'unknown';
            summary.byType[type] = (summary.byType[type] || 0) + 1;
        }

        return {
            findings,
            summary,
            scanDuration: Date.now() - startTime
        };
    }
}

export default NucleiScanAgent;
