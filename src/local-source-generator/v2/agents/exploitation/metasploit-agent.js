/**
 * MetasploitAgent - Framework exploitation via msfrpc
 * 
 * Connects to Metasploit RPC daemon to execute auxiliary scanners
 * and exploits based on discovered tech stack.
 * 
 * Features:
 * - Managed msfrpcd: Auto-starts the RPC daemon if not running
 * - Dual Mode: 'recon' (auxiliary/scanners) and 'exploitation' (exploits)
 * - Intelligent Module Selection: Tech-stack aware module targetting
 */

import { BaseAgent } from '../base-agent.js';
import { CLAIM_TYPES } from '../../epistemics/ledger.js';
import { spawn } from 'child_process';
import chalk from 'chalk';
import fetch from 'node-fetch';
import msgpack from 'msgpack5';

const pack = msgpack();

// Default msfrpcd connection settings
const DEFAULT_MSFRPC_CONFIG = {
    host: '127.0.0.1',
    port: 55553,
    ssl: true,
    user: 'msf',
    password: 'msf',
    autoStart: true,         // Attempt to auto-start msfrpcd
    startupTimeout: 60000,   // Wait up to 60s for startup
    binPath: 'msfrpcd'       // Path to binary
};

/**
 * Simple MSFRPC client using fetch
 */
class MsfrpcClient {
    constructor(config = {}) {
        this.config = { ...DEFAULT_MSFRPC_CONFIG, ...config };
        this.token = null;
        this.process = null;
        this.manuallyStarted = false;
        this.quiet = config.quiet || false;
    }

    log(msg) {
        if (!this.quiet) console.log(msg);
    }

    /**
     * Check if port is open
     */
    async isPortOpen() {
        try {
            const protocol = this.config.ssl ? 'https' : 'http';
            const url = `${protocol}://${this.config.host}:${this.config.port}/api/`;

            await fetch(url, {
                method: 'HEAD',
                agent: new (await import('https')).Agent({ rejectUnauthorized: false })
            }).catch(e => {
                const code = e.code || e.cause?.code;
                if (code === 'ECONNREFUSED') throw e;

                // Log weird errors that aren't connection refused
                if (e.message !== 'fetch failed') this.log(chalk.gray(`  [Metasploit] Probe error: ${e.message}`));
            });
            return true;
        } catch (e) {
            const code = e.code || e.cause?.code;
            if (code === 'ECONNREFUSED') return false;
            return true; // Other errors mean port is listening
        }
    }

    async startDaemon() {
        if (this._starting) return; // Prevent re-entry
        this._starting = true;

        return new Promise((resolve, reject) => {
            this.log(chalk.blue(`  [Metasploit] Starting msfrpcd on port ${this.config.port}...`));

            const args = [
                '-P', this.config.password,
                '-U', this.config.user,
                '-p', this.config.port.toString(),
                '-a', this.config.host,
                // '-S', // SSL managed below
                '-f',  // Foreground
                '-n'   // No DB (Explicitly disable DB for speed/reliability)
            ];

            // Only disable SSL if explicitly false
            if (!this.config.ssl) {
                args.push('-S');
            }

            try {
                this.process = spawn(this.config.binPath, args, {
                    stdio: ['ignore', 'pipe', 'pipe'],
                    detached: false
                });

                this.process.stdout.on('data', (data) => {
                    this.log(chalk.gray(`  [msfrpcd] ${data.toString().trim()}`));
                });

                this.process.stderr.on('data', (data) => {
                    this.log(chalk.gray(`  [msfrpcd err] ${data.toString().trim()}`));
                });

                this.manuallyStarted = true;

                this.process.on('error', (err) => {
                    this._starting = false;
                    if (err.code === 'ENOENT') {
                        reject(new Error(`msfrpcd binary not found at '${this.config.binPath}'. Is Metasploit installed?`));
                    } else {
                        reject(err);
                    }
                });

                // Wait for port to become available
                let attempts = 0;
                let started = false;
                const maxAttempts = this.config.startupTimeout / 1000;

                const checkInterval = setInterval(async () => {
                    if (started) return; // Ignore if already started

                    if (attempts >= maxAttempts) {
                        clearInterval(checkInterval);
                        this._starting = false;
                        if (this.process) this.process.kill();
                        reject(new Error('Timed out waiting for msfrpcd to start'));
                        return;
                    }

                    attempts++;
                    try {
                        const isOpen = await this.isPortOpen();
                        if (isOpen && !started) {
                            started = true;
                            clearInterval(checkInterval);
                            this.log(chalk.green('  [Metasploit] msfrpcd started successfully.'));
                            this._starting = false;
                            // Give it a split second
                            setTimeout(() => resolve(true), 1000);
                        }
                    } catch (e) {
                        // Ignore error during check
                    }
                }, 1000);

            } catch (err) {
                this._starting = false;
                reject(err);
            }
        });
    }

    async connect() {
        // Check if running
        let isRunning = await this.isPortOpen();

        // Auto-start if configured and not running
        if (!isRunning && this.config.autoStart) {
            try {
                await this.startDaemon();
                isRunning = true;
            } catch (e) {
                this.log(chalk.yellow(`  [Metasploit] Auto-start failed: ${e.message}`));
                throw e;
            }
        }

        if (!isRunning) {
            throw new Error(`MSFRPC not running on ${this.config.host}:${this.config.port} and auto-start failed or disabled`);
        }

        const response = await this.call('auth.login', [
            this.config.user,
            this.config.password
        ]);

        if (response?.result === 'success') {
            this.token = response.token;
            return true;
        }
        this.log(chalk.red(`  [Metasploit] Auth failed. Response: ${JSON.stringify(response)}`));
        throw new Error('MSFRPC authentication failed');
    }

    async call(method, params = []) {
        const protocol = this.config.ssl ? 'https' : 'http';
        const url = `${protocol}://${this.config.host}:${this.config.port}/api/`;

        const requestParams = this.token ? [this.token, ...params] : params;
        const body = [method, ...requestParams];

        try {
            // Self-signed certs are expected
            const agent = new (await import('https')).Agent({ rejectUnauthorized: false });

            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'binary/message-pack' },
                body: pack.encode(body),
                agent: this.config.ssl ? agent : undefined
            });

            const buffer = await response.arrayBuffer();
            const data = pack.decode(Buffer.from(buffer));
            const decoded = this._unwrapMsgPack(data);

            return decoded;
        } catch (error) {
            this.log(chalk.red(`  [Metasploit] RPC Call Error (${method}): ${error.message}`));
            if (error.cause) this.log(chalk.red(`  [Metasploit] Cause: ${JSON.stringify(error.cause, Object.getOwnPropertyNames(error.cause))}`));
            throw new Error(`MSFRPC call failed: ${error.message}`);
        }
    }

    _unwrapMsgPack(data) {
        if (Buffer.isBuffer(data)) {
            return data.toString('utf8');
        }
        if (data instanceof Map) {
            const obj = {};
            for (const [key, value] of data) {
                const startKey = Buffer.isBuffer(key) ? key.toString('utf8') : key;
                obj[startKey] = this._unwrapMsgPack(value);
            }
            return obj;
        }
        if (Array.isArray(data)) {
            return data.map(item => this._unwrapMsgPack(item));
        }
        return data;
    }

    async executeModule(type, name, options) {
        return this.call('module.execute', [type, name, options]);
    }

    async disconnect() {
        try {
            if (this.token) {
                await this.call('auth.logout', [this.token]).catch(() => { });
                this.token = null;
            }

            // Kill child process if we started it
            if (this.process && this.manuallyStarted) {
                this.log(chalk.gray('  [Metasploit] Stopping managed msfrpcd...'));
                this.process.kill();
                this.process = null;
            }
        } catch (e) {
            // Ignore errors during cleanup
        }
    }
}

export class MetasploitAgent extends BaseAgent {
    constructor(options = {}) {
        // Allow overriding name for "MetasploitRecon" vs "MetasploitExploit"
        const name = options.name || 'MetasploitAgent';
        super(name, options);

        this.defaultMode = options.defaultMode || 'recon'; // recon or exploitation

        this.inputs_schema = {
            type: 'object',
            required: ['target'],
            properties: {
                target: { type: 'string', description: 'Target host/URL' },
                mode: { type: 'string', enum: ['recon', 'exploitation'], default: this.defaultMode },
                techStack: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'Detected technologies'
                },
                msfrpcConfig: { type: 'object' },
                maxModules: { type: 'number', default: 10 }
            }
        };

        this.outputs_schema = {
            type: 'object',
            properties: {
                modulesExecuted: { type: 'array' },
                findings: { type: 'array' },
                connected: { type: 'boolean' }
            }
        };

        this.requires = {
            evidence_kinds: ['tech_fingerprint', 'service_detected'],
            model_nodes: ['technologies', 'services']
        };

        this.emits = {
            evidence_events: ['msf_scan_result', 'exploit_attempt', 'vulnerability_confirmed'],
            model_updates: ['vulnerability_confirmed', 'service_compromised', 'service_info'],
            claims: ['vulnerability_confirmed', 'service_exposed', 'info_disclosure'],
            artifacts: ['metasploit_results.json']
        };

        this.default_budget = {
            max_time_ms: 600000,        // 10 minutes
            max_network_requests: 500,
            max_tokens: 0,
            max_tool_invocations: 50
        };

        // --- MODULE CATALOG ---

        // SAFE RECON (Auxiliary Scanners)
        // SAFE RECON (Auxiliary Scanners)
        this.reconModules = [
            // --- HTTP General ---
            'auxiliary/scanner/http/http_version',
            'auxiliary/scanner/http/robots_txt',
            'auxiliary/scanner/http/title',
            'auxiliary/scanner/http/options',
            'auxiliary/scanner/http/http_header',
            'auxiliary/scanner/http/ssl',
            'auxiliary/scanner/http/cert',
            'auxiliary/scanner/http/dir_scanner',
            'auxiliary/scanner/http/files_dir',
            'auxiliary/scanner/http/backup_file',
            'auxiliary/scanner/http/git_scanner',
            'auxiliary/scanner/http/svn_scanner',
            'auxiliary/scanner/http/ds_store_scanner',
            'auxiliary/scanner/http/trace',

            // --- Infrastructure ---
            'auxiliary/scanner/ssh/ssh_version',
            'auxiliary/scanner/ssh/ssh_enumusers',
            'auxiliary/scanner/ftp/ftp_version',
            'auxiliary/scanner/ftp/anonymous',
            'auxiliary/scanner/smtp/smtp_version',
            'auxiliary/scanner/smtp/smtp_enum',
            'auxiliary/scanner/dns/dns_amp',
            'auxiliary/scanner/portscan/tcp',

            // --- Databases (Safe) ---
            'auxiliary/scanner/mysql/mysql_version',
            'auxiliary/scanner/mysql/mysql_login', // (Safe brute, usually disabled by policy but good to have)
            'auxiliary/scanner/postgres/postgres_version',
            'auxiliary/scanner/mssql/mssql_ping',
            'auxiliary/scanner/redis/redis_server',
            'auxiliary/scanner/mongodb/mongodb_login', // Probe
            'auxiliary/scanner/elasticsearch/indices',

            // --- SMB/NetBIOS ---
            'auxiliary/scanner/smb/smb_version',
            'auxiliary/scanner/smb/smb_enumshares', // Safe listing
            'auxiliary/scanner/netbios/nbname',

            // --- Web Frameworks ---
            'auxiliary/scanner/http/wordpress_scanner',
            'auxiliary/scanner/http/joomla_version',
            'auxiliary/scanner/http/drupal_views_user_enum',
            'auxiliary/scanner/http/tomcat_enum',
            'auxiliary/scanner/http/jenkins_enum',
            'auxiliary/scanner/http/rails_xml_yaml_scanner',
        ];

        // CMS / Tech Specific Recon (Enhanced)
        this.techReconModules = {
            wordpress: [
                'auxiliary/scanner/http/wordpress_login_enum',
                'auxiliary/scanner/http/wordpress_user_enum',
                'auxiliary/scanner/http/wordpress_xmlrpc_login'
            ],
            joomla: ['auxiliary/scanner/http/joomla_pages'],
            drupal: [], // Already in general if generic
            tomcat: ['auxiliary/scanner/http/tomcat_mgr_login'],
            jenkins: ['auxiliary/scanner/http/jenkins_command'],
            mysql: ['auxiliary/scanner/mysql/mysql_schemadump'], // Only if creds found
            postgres: ['auxiliary/scanner/postgres/postgres_dbname_flag_injection'],
            ssh: ['auxiliary/scanner/ssh/libssh_auth_bypass'], // Safe check
            smb: ['auxiliary/scanner/smb/smb_ms17_010'], // EternalBlue check (Safe)
            iis: ['auxiliary/scanner/http/iis_internal_ip', 'auxiliary/scanner/http/iis_shortname_digest_auth_bypass'],
            nginx: [],
            apache: ['auxiliary/scanner/http/apache_optionsbleed'],
        };

        // EXPLOITATION (Active Exploits & Intrusive Scanners)
        // Only run in exploitation mode
        this.exploitModules = {
            tomcat: ['exploit/multi/http/tomcat_mgr_upload'],
            jenkins: ['exploit/multi/http/jenkins_script_console'],
            wordpress: ['exploit/unix/webapp/wp_admin_shell_upload'],
        };
    }

    /**
     * Select relevant modules based on mode and tech stack
     */
    selectModules(mode, techStack) {
        const modules = new Set();
        const techLower = techStack.map(t => t.toLowerCase());

        if (mode === 'recon') {
            // 1. Add general safe recon modules
            this.reconModules.forEach(m => modules.add(m));

            // 2. Add tech-specific recon
            for (const [techkey, techModules] of Object.entries(this.techReconModules)) {
                if (techLower.some(t => t.includes(techkey))) {
                    techModules.forEach(m => modules.add(m));
                }
            }
        }
        else if (mode === 'exploitation') {
            // 1. Add known exploits for detected tech
            for (const [techkey, techExploits] of Object.entries(this.exploitModules)) {
                if (techLower.some(t => t.includes(techkey))) {
                    techExploits.forEach(m => modules.add(m));
                }
            }
        }

        return Array.from(modules);
    }

    parseTarget(target) {
        try {
            const url = new URL(target);
            return {
                host: url.hostname,
                port: url.port || (url.protocol === 'https:' ? 443 : 80),
                ssl: url.protocol === 'https:',
                uri: url.pathname || '/'
            };
        } catch {
            return { host: target, port: 80, ssl: false, uri: '/' };
        }
    }

    async run(ctx, inputs) {
        const {
            target,
            mode = this.defaultMode, // Use configured default if not overridden
            techStack = [],
            msfrpcConfig = {},
            maxModules = 50, // Increased default
            quiet = true // Default to quiet in agent usage to prevent progress bar corruption
        } = inputs;

        const client = new MsfrpcClient({ ...msfrpcConfig, quiet });
        let connected = false;

        try {
            await client.connect();
            connected = true;
            // console.log(chalk.green(`  [${this.name}] Connected to msfrpcd (${mode} mode)`));
        } catch (error) {
            if (!inputs.quiet) console.log(chalk.yellow(`  [${this.name}] Skipped: ${error.message}`));
            return {
                connected: false,
                error: error.message,
                modulesExecuted: [],
                findings: []
            };
        }

        const findings = [];
        const modulesExecuted = [];

        try {
            const targetInfo = this.parseTarget(target);
            const selectedModules = this.selectModules(mode, techStack).slice(0, maxModules);
            this.setStatus(`Found ${selectedModules.length} modules for ${techStack.join(', ') || 'general'}`);

            if (!inputs.quiet) console.log(chalk.blue(`  [${this.name}] Running ${selectedModules.length} modules (${mode})...`));

            for (const modulePath of selectedModules) {
                // Determine module type
                const [type, ...nameParts] = modulePath.split('/');
                const moduleName = nameParts.join('/');

                // Prepare options
                const options = {
                    RHOSTS: targetInfo.host,
                    RPORT: targetInfo.port,
                    SSL: targetInfo.ssl,
                    TARGETURI: targetInfo.uri,
                    THREADS: 5
                };

                // Only actually run if we have budget
                if (ctx.budget?.toolInvocations >= ctx.config.budget?.max_tool_invocations) {
                    break;
                }
                try {
                    const result = await client.executeModule(type, moduleName, options);

                    modulesExecuted.push({
                        module: modulePath,
                        status: 'executed',
                        jobId: result?.job_id
                    });

                } catch (e) {
                    modulesExecuted.push({ module: modulePath, status: 'error', error: e.message });
                }
            }

            // EMIT EVIDENCE
            ctx.emitEvidence({
                source: this.name,
                event_type: 'msf_scan_result',
                target: target,
                payload: {
                    mode: mode,
                    module_count: modulesExecuted.length,
                    modules: modulesExecuted.map(m => ({ module: m.module, status: m.status })),
                    summary: `Executed ${modulesExecuted.length} Metasploit modules (${mode})`
                }
            });
            this.setStatus('Scanning complete, evidence emitted.');

        } finally {
            await client.disconnect();
        }

        return {
            connected,
            modulesExecuted,
            findings,
            success: true
        };
    }
}

export default MetasploitAgent;
