/**
 * DocumentationAgent - Documentation generation agent
 * 
 * Generates model-driven documentation with epistemic provenance.
 */

import { BaseAgent } from '../base-agent.js';
import { getLLMClient, LLM_CAPABILITIES } from '../../orchestrator/llm-client.js';

export class DocumentationAgent extends BaseAgent {
    constructor(options = {}) {
        super('DocumentationAgent', options);

        this.inputs_schema = {
            type: 'object',
            required: ['target', 'outputDir'],
            properties: {
                target: { type: 'string' },
                outputDir: { type: 'string' },
            },
        };

        this.outputs_schema = {
            type: 'object',
            properties: {
                doc_files: { type: 'array' },
            },
        };

        this.requires = {
            evidence_kinds: [],
            model_nodes: ['endpoint', 'component', 'auth_flow', 'workflow'],
        };

        this.emits = {
            evidence_events: [],
            model_updates: [],
            claims: [],
            artifacts: ['documentation'],
        };

        this.default_budget = {
            max_time_ms: 120000,
            max_network_requests: 5,
            max_tokens: 10000,
            max_tool_invocations: 5,
        };

        this.llm = getLLMClient();
    }

    async run(ctx, inputs) {
        const { target, outputDir } = inputs;
        const { fs, path } = await import('zx');

        const results = {
            doc_files: [],
        };

        await fs.mkdir(outputDir, { recursive: true });

        // Generate main README
        const readme = await this.generateReadme(ctx, target);
        const readmePath = path.join(outputDir, 'README.md');
        await fs.writeFile(readmePath, readme);
        results.doc_files.push(readmePath);

        // Generate API documentation
        const apiDocs = await this.generateAPIDocs(ctx, target);
        const apiDocsPath = path.join(outputDir, 'API.md');
        await fs.writeFile(apiDocsPath, apiDocs);
        results.doc_files.push(apiDocsPath);

        // Generate architecture documentation
        const archDocs = await this.generateArchDocs(ctx, target);
        const archDocsPath = path.join(outputDir, 'ARCHITECTURE.md');
        await fs.writeFile(archDocsPath, archDocs);
        results.doc_files.push(archDocsPath);

        // Generate evidence map
        const evidenceMap = await this.generateEvidenceMap(ctx, target);
        const evidenceMapPath = path.join(outputDir, 'EVIDENCE.md');
        await fs.writeFile(evidenceMapPath, evidenceMap);
        results.doc_files.push(evidenceMapPath);

        // Register in manifest
        for (const docPath of results.doc_files) {
            ctx.manifest.addEntry({
                path: docPath,
                generated_from: [],
                evidence_refs: [],
            });
        }

        return results;
    }

    /**
     * Generate main README
     */
    async generateReadme(ctx, target) {
        const endpoints = ctx.targetModel.getEndpoints();
        const components = ctx.targetModel.getEntitiesByType('component');
        const ledgerStats = ctx.ledger.stats();

        return `# ${new URL(target).hostname} - LSG v2 Analysis

> Auto-generated documentation from Local Source Generator v2

## Overview

- **Target**: ${target}
- **Generated**: ${new Date().toISOString()}
- **LSG Version**: 2.0.0

## Summary

| Metric | Value |
|--------|-------|
| Endpoints Discovered | ${endpoints.length} |
| Components Identified | ${components.length} |
| Claims Generated | ${ledgerStats.total_claims} |
| Average Confidence | ${(ledgerStats.avg_belief * 100).toFixed(1)}% |
| Average Uncertainty | ${(ledgerStats.avg_uncertainty * 100).toFixed(1)}% |

## Quick Links

- [API Documentation](./API.md)
- [Architecture](./ARCHITECTURE.md)
- [Evidence Map](./EVIDENCE.md)

## Generated Artifacts

Check the \`src/\` directory for generated source code and schemas.

## Epistemic Note

> This documentation is generated from black-box reconnaissance.
> All claims are probabilistic and should be validated.
> See EVIDENCE.md for provenance details.

---

*Generated by Shannon LSG v2*
`;
    }

    /**
     * Generate API documentation
     */
    async generateAPIDocs(ctx, target) {
        const endpoints = ctx.targetModel.getEndpoints();

        const byMethod = {
            GET: endpoints.filter(e => e.attributes.method === 'GET'),
            POST: endpoints.filter(e => e.attributes.method === 'POST'),
            PUT: endpoints.filter(e => e.attributes.method === 'PUT'),
            DELETE: endpoints.filter(e => e.attributes.method === 'DELETE'),
            PATCH: endpoints.filter(e => e.attributes.method === 'PATCH'),
        };

        let doc = `# API Documentation

> Discovered endpoints for ${target}

## Summary

| Method | Count |
|--------|-------|
${Object.entries(byMethod).map(([m, eps]) => `| ${m} | ${eps.length} |`).join('\n')}

---

`;

        for (const [method, eps] of Object.entries(byMethod)) {
            if (eps.length === 0) continue;

            doc += `## ${method} Endpoints\n\n`;

            for (const ep of eps) {
                const path = ep.attributes.path;
                const params = ep.attributes.params || [];
                const confidence = this.getConfidence(ctx, ep);

                doc += `### \`${method} ${path}\`\n\n`;
                doc += `**Confidence**: ${(confidence * 100).toFixed(0)}%\n\n`;

                if (params.length > 0) {
                    doc += '**Parameters**:\n\n';
                    doc += '| Name | Location | Type |\n';
                    doc += '|------|----------|------|\n';
                    for (const p of params) {
                        doc += `| ${p.name} | ${p.location} | ${p.type || 'string'} |\n`;
                    }
                    doc += '\n';
                }

                doc += '---\n\n';
            }
        }

        return doc;
    }

    /**
     * Generate architecture documentation
     */
    async generateArchDocs(ctx, target) {
        const components = ctx.targetModel.getEntitiesByType('component');
        const services = ctx.targetModel.getEntitiesByType('service');
        const authFlows = ctx.targetModel.getEntitiesByType('auth_flow');
        const workflows = ctx.targetModel.getEntitiesByType('workflow');

        let doc = `# Architecture Documentation

> Inferred architecture for ${target}

## Components

`;

        if (components.length === 0) {
            doc += '*No components identified*\n\n';
        } else {
            for (const comp of components) {
                doc += `### ${comp.attributes.name}\n\n`;
                doc += `- **Type**: ${comp.attributes.type || 'unknown'}\n`;
                doc += `- **Description**: ${comp.attributes.description || 'N/A'}\n`;
                if (comp.attributes.endpoints?.length > 0) {
                    doc += `- **Endpoints**: ${comp.attributes.endpoints.join(', ')}\n`;
                }
                doc += '\n';
            }
        }

        doc += '## Authentication\n\n';

        if (authFlows.length === 0) {
            doc += '*No authentication flows identified*\n\n';
        } else {
            for (const auth of authFlows) {
                doc += `- **Mechanism**: ${auth.attributes.mechanism}\n`;
                doc += `- **Storage**: ${auth.attributes.session_storage}\n\n`;
            }
        }

        doc += '## Workflows\n\n';

        if (workflows.length === 0) {
            doc += '*No workflows identified*\n\n';
        } else {
            for (const wf of workflows) {
                doc += `### ${wf.attributes.name}\n\n`;
                const steps = wf.attributes.steps || [];
                for (const step of steps) {
                    doc += `1. ${step.step} â†’ \`${step.endpoint}\`\n`;
                }
                doc += '\n';
            }
        }

        return doc;
    }

    /**
     * Generate evidence map
     */
    async generateEvidenceMap(ctx, target) {
        const events = ctx.evidenceGraph.getAllEvents();
        const claims = Array.from(ctx.ledger.claims.values());

        const eventsBySource = {};
        for (const event of events) {
            const source = event.source || 'unknown';
            if (!eventsBySource[source]) {
                eventsBySource[source] = [];
            }
            eventsBySource[source].push(event);
        }

        let doc = `# Evidence Map

> Provenance and uncertainty documentation for ${target}

## Evidence Sources

| Source | Events | Types |
|--------|--------|-------|
${Object.entries(eventsBySource).map(([source, evs]) => {
            const types = [...new Set(evs.map(e => e.event_type))].join(', ');
            return `| ${source} | ${evs.length} | ${types} |`;
        }).join('\n')}

## Claim Summary

| Type | Count | Avg Confidence |
|------|-------|----------------|
${this.summarizeClaims(claims, ctx)}

## High Uncertainty Items

The following items have uncertainty > 50% and may require manual verification:

`;

        const uncertainClaims = claims.filter(c => c.getOpinion(ctx.ledger.config).u > 0.5);

        if (uncertainClaims.length === 0) {
            doc += '*No high-uncertainty claims*\n';
        } else {
            for (const claim of uncertainClaims.slice(0, 20)) {
                const opinion = claim.getOpinion(ctx.ledger.config);
                doc += `- **${claim.claim_type}**: ${claim.subject}\n`;
                doc += `  - Uncertainty: ${(opinion.u * 100).toFixed(0)}%\n`;
                doc += `  - Evidence refs: ${claim.evidence_refs.length}\n\n`;
            }
        }

        doc += `
---

## Why We Think This

Each claim in this analysis is derived from multiple evidence sources.
The confidence scores reflect the strength and consistency of the evidence.

**Legend**:
- **b (belief)**: Degree of belief the claim is true
- **d (disbelief)**: Degree of belief the claim is false
- **u (uncertainty)**: Degree of uncertainty
- **P**: Expected probability (b + a*u)

---

*Evidence collected by Shannon LSG v2*
`;

        return doc;
    }

    summarizeClaims(claims, ctx) {
        const byType = {};

        for (const claim of claims) {
            const type = claim.claim_type;
            if (!byType[type]) {
                byType[type] = { count: 0, totalConf: 0 };
            }
            byType[type].count++;
            byType[type].totalConf += claim.getExpectedProbability(ctx.ledger.config);
        }

        return Object.entries(byType)
            .map(([type, data]) => {
                const avgConf = data.count > 0 ? data.totalConf / data.count : 0;
                return `| ${type} | ${data.count} | ${(avgConf * 100).toFixed(0)}% |`;
            })
            .join('\n');
    }

    getConfidence(ctx, endpoint) {
        const claims = ctx.ledger.getClaimsForSubject(endpoint.id);
        if (claims.length === 0) return 0.5;
        return claims[0].getExpectedProbability(ctx.ledger.config);
    }
}

export default DocumentationAgent;
